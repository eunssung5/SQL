## 2021.01.20

### JOIN



> SELECT  EMP_NAME, SALARY
> FROM    EMPLOYEE
> WHERE   DEPT_ID = '50'
> OR      DEPT_ID IS NULL
> ORDER BY SALARY DESC;
>
> SELECT  EMP_NAME , HIRE_DATE, DEPT_ID
> FROM    EMPLOYEE
> WHERE   HIRE_DATE > TO_DATE('20030101','YYYYMMDD')
> ORDER BY DEPT_ID DESC, HIRE_DATE, EMP_DATE;
>
> SELECT  EMP_NAME AS 이름,
>         HIRE_DATE AS 입사일,
>         DEPT_ID AS 부서코드
> FROM    EMPLOYEE
> WHERE   HIRE_DATE > TO_DATE('20030101','YYYYMMDD')
> ORDER BY 부서코드 DESC, 입사일, 이름;
>
> SELECT  EMP_NAME AS 이름,
>         HIRE_DATE AS 입사일,
>         DEPT_ID AS 부서코드
> FROM    EMPLOYEE
> WHERE   HIRE_DATE > TO_DATE('20030101','YYYYMMDD')
> ORDER BY 3 DESC, 2,1;
>
> SELECT  EMP_NAME, DEPT_ID, COUNT(*)
> FROM    EMPLOYEE
> GROUP BY EMP_NAME, DEPT_ID;
> --GROUP BY는 별칭을 사용할수 없다.
> SELECT  DEPT_ID
>         MAX(SUM(SALARY)
> FROM    EMPLOYEE
> GROUP BY DEPT_ID;
> --WHERE절에는 그룹함수 쓸수없음
> --HAVING절에 쓸수있음.
> SELECT  DEPT_ID,SUM(SALARY)
> FROM    EMPLOYEE
> GROUP BY DEPT_ID
> HAVING  SUM(SALARY)>9000000
>
> ----JOIN
>
> --오라클전용구문
> --LEFT JOIN과 RIGHT JOIN처럼 만드는게 가능하다.(+)
> --FULL JOIN은 불가능하다.
> --ANSI표준화로 바꿀수 있다.
> SELECT EMP_NAME, DEPT_NAME
> FROM    EMPLOYEE E,
>         DEPARTMENT D
> WHERE   E.DEPT_ID = D.DEPT_ID
>
> SELECT  EMP_NAME,
>         DEPT_NAME,
>         D.DEPT_ID
> FROM    EMPLOYEE E,
>         DEPARTMENT D
> WHERE   E.DEPT_ID = D.DEPT_ID;
>
> SELECT EMP_NAME,
>         DEPT_NAME,
>         D.DEPT_ID
> FROM    EMPLOYEE E,
>         DEPARTMENT D
> WHERE   D.DEPT_ID=E.DEPT_ID(+)
> --ANSI 표준화
> --USING과 ON을 이용한 JOIN
> SELECT  ...
> FROM    table1
> {[INNER] JOIN table2 ON (condition1 [AND condition2 ...]) |
> [INNER] JOIN table2 USING (column1 [, ...]) |
> LEFT|RIGHT|FULL [OUTER] JOIN table2 ON (condition1 [ AND condition2 ...])|
> LEFT|RIGHT|FULL [OUTER] JOIN table2 USING (column1 [, ...]) }
> WHERE   ...
> GROUP BY column_name | expr
> HAVING   condition
> ORDER BY 기준1
>
> SELECT EMP_NAME,
>         DEPT_NAME
> FROM    EMPLOYEE
> JOIN    DEPARTMENT USING(DEPT_ID);
>
> SELECT EMP_NAME,
>         DEPT_NAME
> FROM    EMPLOYEE E
> JOIN    DEPARTMENT D ON(E.DEPT_ID=D.DEPT_ID);
>
>
> SELECT EMP_NAME,
>         DEPT_NAME,
>         LOC_DESCRIBE
> FROM    EMPLOYEE E
> JOIN    DEPARTMENT D ON(E.DEPT_ID=D.DEPT_ID)
> JOIN    LOCATION L ON(L.LOCATION_ID=D.LOC_ID);
>
> --[OUTER] JOIN
> SELECT EMP_NAME,
>         DEPT_NAME
> FROM    EMPLOYEE
> --LEFT JOIN    DEPARTMENT USING(DEPT_ID);
> --RIGHT JOIN    DEPARTMENT USING(DEPT_ID);
> FULL JOIN    DEPARTMENT USING(DEPT_ID);
>
> --NON - EQUI JOIN
> SELECT EMP_NAME,
>         SALARY,
>         SLEVEL
> FROM    EMPLOYEE , SAL_GRADE
> WHERE   SALARY BETWEEN LOWEST AND HIGHEST;
> =
> SELECT EMP_NAME,
>         SALARY,
>         SLEVEL
> FROM    EMPLOYEE
> JOIN    SAL_GRADE ON(SALARY BETWEEN LOWEST AND HIGHEST);
>
> SELECT E.EMP_NAME, M.EMP_NAME,S.EMP_NAME
> FROM    EMPLOYEE E
> LEFT JOIN    EMPLOYEE M ON(E.MGR_ID = M.EMP_ID)
> LEFT JOIN    EMPLOYEE S ON(M.MGR_ID = S.EMP_ID)
> ORDER BY 1;
>
>
> --ON EXAMPLE
> SELECT E.EMP_NAME,
>         E.SALARY,
>         S.SLEVEL,
>         J.JOB_TITLE,
>         D.DEPT_NAME,
>         C.COUNTRY_NAME,
>         L.LOC_DESCRIBE
> FROM    EMPLOYEE E
> JOIN    JOB J USING(JOB_ID)
> JOIN    SAL_GRADE S ON(E.SALARY BETWEEN LOWEST AND HIGHEST)
> JOIN    DEPARTMENT D USING(DEPT_ID)
> JOIN    LOCATION L ON (L.LOCATION_ID=D.LOC_ID)
> JOIN    COUNTRY C USING(COUNTRY_ID);
>
> --직급이 '대리'이고 지역이 '아시아'로 시작하는 필터링
> SELECT E.EMP_NAME,
>         E.SALARY,
>         S.SLEVEL,
>         J.JOB_TITLE,
>         D.DEPT_NAME,
>         L.LOC_DESCRIBE,
>         C.COUNTRY_NAME
>
> FROM    EMPLOYEE E
> JOIN    JOB J USING(JOB_ID)
> JOIN    SAL_GRADE S ON(E.SALARY BETWEEN LOWEST AND HIGHEST)
> JOIN    DEPARTMENT D USING(DEPT_ID)
> JOIN    LOCATION L ON (L.LOCATION_ID=D.LOC_ID)
> JOIN    COUNTRY C USING(COUNTRY_ID)
> WHERE JOB_TITLE = '대리' AND LOC_DESCRIBE LIKE'아시아%';